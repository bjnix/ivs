USAGE INSTRUCTIONS
------------------
Here is an overview of how the distributed version of STLRender works:

1) The Master program is run on LOCAL HARDWARE that you have physical access to.

2) On the HEAD NODE of the cluster, the LAUNCH SCRIPT is run.
    2a) The launch script automatically launches a copy of the Slave program
        on every available graphics node.
    2b) The launch script then automatically runs a RELAY which is responsible
        for accepting state data from the MASTER and forwarding it to the SLAVES.

There are two versions of the launch script:

 - STLStartLocal.sh - Designed to be used for debugging on your own
   computer. This script runs the master program, a relay program, and
   a single slave program all on the same computer.

 - STLStartIVS.sh - Designed to display imagery on the display
   wall. You should run this script on the local machine. It will
   automatically ssh into IVS, copy your local files onto IVS, start
   the relay process, and start the individual slave processes on each
   tile node.

 - STLEmergencySTop.sh - Designed to be used with STLStartIVS.sh. This
   program will kill any stray Slave or Relay processes.


The MASTER program forwards state data via UDP packets to relay
program running on the head node of the cluster.

The RELAY, running on the head node of the cluster, listens for
packets from the master program and automatically forwards them to on
IP address (which could be a broadcast address).

The SLAVEs listen for packets on the appropriate port. Upon receipt, they
immediately decode the packets and update their state with the data.


DEVELOPING YOUR OWN DISTRIBUTED RENDERING PROGRAMS
--------------------------------------------------
This demo illustrates how to accomplish distributed rendering on a graphics
cluster using only UDP packets, without relying on libraries such as
Chromium. You can use this as an example to add this functionality to your
own programs. Here is a brief explanation of how it works:

-You must modify STLRenderMutant.cpp which contains the code for both
 the master and the slave computer. Look carefully at the preprocessor
 directives in the code. The can come in many varieties such as

#ifdef STL_MASTER
	   C++ code for the master program
#else
		C++ code for the slave program
#endif

#ifndef STL_MASTER
	   C++ code for the SLAVE program. #if*n*def means "if not defined"
#endif


-The master's responsibility is to forward its current state data via
UDP packets. Which data in your program is necessary for the camera to know
where to display? This is probably position and orientation data. Set up
the master version of your program to send this data via UDP, using this
demo as an example. To guarantee good performance, YOU MAY WANT TO CAP THE
RATE AT WHICH THE MASTER SENDS UDP PACKETS TO ABOUT 60 PER SECOND, but
feel free to experiment.

-You will need a simple relay program. The relay's ONLY responsibility is to
RECEIVE packets from the MASTER and immediately SEND those packets to the
SLAVES (for greatest efficiency, just broadcast them).

-The SLAVES receive state data generated by the MASTER and use that to
update their displays. When initialized, the slave must be given VIEWPORT
INFORMATION telling it WHICH PART of the display it is responsible for (e.g.,
the upper-left, the middle-right, etc.). This is what enables the slaves to
correct divide their views using the glFrustum function. See the demo for
an example.

-Don't forget to include a KILL SIGNAL that tells the slaves (and the relay)
when to quit running. In the demo, the slaves and relay terminate when they
receive X, Y, and Z position values of less than -999999. (But remember to
have the relay forward the kill packet before it terminates itself!)



SUPPORT
-------
If you have questions, comments, or need assistance with this demo or
using the demo to distribute rendering in your own programs, please
contact
        jwwalker@mtu.edu
